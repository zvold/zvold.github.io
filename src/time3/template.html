<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Punch Clock 3000</title>
    <style>
      html {
        font-size: 100%;
      }
      body {
        background-color: #aaa;
      }
      * {
        font-family: serif;
        font-size: 1rem;
      }

      .root-container {
        display: grid;
        grid-template-columns: 1fr;
        width: fit-content;
        position: absolute;
        left: 10px; top: 10px;
      }

      #svg-container {
        width: 401px;
        height: 40px;
      }

      .text-container {
         display: flex;
         justify-content: space-between;
      }

      .button-container {
        display: flex;
      }
      .button-container button {
        margin: 10px 10px 10px 0px;
      }

      button.unpressed {
        box-shadow: inset -1px -1px #0a0a0a,
                    inset  1px  1px #ffffff,
                    inset -2px -2px grey,
                    inset  2px  2px #dfdfdf;
        background-color: #ddd;
        border: 1px solid #aaa;
      }
      button.pressed, button:active {
        box-shadow: inset -1px -1px #ffffff,
                    inset  1px  1px #0a0a0a,
                    inset -2px -2px #dfdfdf,
                    inset  2px  2px #808080;
        background-color: #ddd;
        border: 1px solid #aaa;
      }

      #butterbar {
        width: 100%;
        background-color: #ad8900;
        border-radius: 5px;
        text-align: center;
        padding: 5px 0px;
      }
      #butterbar.hidden {
        display: none;
        visibility: hidden;
      }
    </style>
    <script>
      // Main data structure representing the full state of the punch clock.
      // Note that to get the full "work" or "rest" time, the time of the last
      // mode change has to be taken into account.
      var state = {
        "mode": {{.Mode}}, // Mode: one of [ "work", "rest", "off" ].
        "work": {{.Work}}, // Work time in seconds.
        "rest": {{.Rest}}, // Rest time in seconds.
        "modeStart": {{.ModeStart}}, // Time when mode last changed in millis.
      }
      var viewTimer = null;
      var ws = null;
      var reconnectTimer = null;

      // Parse the target percentage from an optional URL parameter 't'.
      const urlParams = new URLSearchParams(window.location.search);
      var target = 75;
      if (urlParams.get('t') != null) {
        const parsedInt = parseInt(urlParams.get('t'))
        if (!isNaN(parsedInt) && parsedInt > 0 && parsedInt <= 100) {
          target = parsedInt;
        }
      }

      // Creates the websocket connection if necessary.
      function createWebSocketConnection() {
        if (ws != null) {
          return;
        }
        const url = new URL(window.location.origin);
        ws = new WebSocket(`ws://${url.hostname}:${url.port}/ws`);
        ws.onopen = function(evt) {
          console.log("websocket onopen()");
          if (reconnectTimer != null) {
            clearInterval(reconnectTimer);
          }
          showButterbar(false);
        }
        ws.onclose = function(evt) {
          console.log("websocket onclose()");
          ws = null;
          reconnectTimer = setInterval(createWebSocketConnection, 5000);
          showButterbar(true);
        }
        ws.onmessage = function(evt) {
          console.log("websocket onmessage(): " + evt.data);
          if (typeof evt.data === "string") {
            updateViewFromServerState(evt.data);
          }
        }
        ws.onerror = function(evt) {
          console.log("websocket onerror(): " + evt.data);
        }
      }

      // Convenience function for calculating the position of the progress bar.
      function ratio(duration) {
        return duration.totalWork / (duration.totalWork + duration.totalRest);
      }

      // Render ready-to-use div element representing the current state.
      // This includes progress bar, correctly pressed buttons, text, etc.
      function renderTemplate() {
        const r = ratio(totalTime());
        const str = template
            .replaceAll("%SPLIT_POS%", 400.0 * r)
            .replaceAll("%REST_WIDTH%", 400.0 * (1.0 - r))
            .replaceAll("%TARGET_X%", 400.0 * target / 100.0);
        return new DOMParser()
            .parseFromString(str, "text/html").body.firstChild;
      }

      // Sets or removes the "fast update" view timer, depending on the mode.
      function setOrClearTimer() {
        if (viewTimer != null) {
          clearInterval(viewTimer)
          viewTimer = null
        }
        const durations = totalTime();
        switch(state.mode) {
          case "work": {
            // Redraw only as frequently as the text changes.
            const delay = durations.totalWork < 3600 ? 1001 : 61000;
            viewTimer = setInterval(redrawView, delay);
            break;
          }
          case "rest": {
            // Redraw only as frequently as the text changes.
            const delay = durations.totalRest < 3600 ? 1001 : 61000;
            viewTimer = setInterval(redrawView, delay);
            break;
          }
          case "off":
            // No need to redraw in the "off" mode as nothing changes.
            break;
        }
      }

      // Changes (potentially) the current mode by requesting the mode change
      // server-side. The client-side state is updated based on server response.
      // TODO: request mode change on mouse-down instead of onclick?
      function changeMode(newMode) {
        if (state.mode == newMode) {
          return;
        }

        // Set pressed/unpressed status for buttons to reduce flicker.
        ["work", "rest", "off"]
            .forEach(function(str) {setPressed(str, newMode == str);});

        // Request server-side mode change.
        sendMessage('{"mode": "' + newMode + '"}');
      }

      // Convenience function to re-draw the specified button as pressed or not.
      // This doesn't mutate the actual state in any way.
      function setPressed(buttonId, isPressed) {
        document
            .getElementById(`button-${buttonId}`)
            .setAttribute("class", isPressed ? "pressed" : "unpressed");
      }

      // Convenience function for updating the butterbar visibility.
      function showButterbar(isVisible) {
        document.getElementById("butterbar")
            .setAttribute("class", isVisible ? "shown" : "hidden");
      }

      // Calculates the total work/rest time in seconds and returns it as a map
      // with keys 'totalRest' and 'totalWork'.
      function totalTime() {
        const addTime = (Date.now() - state.modeStart) / 1000;
        switch (state.mode) {
          case "work":
            return {"totalWork": state.work + addTime, "totalRest": state.rest};
          case "rest":
            return {"totalWork": state.work, "totalRest": state.rest + addTime};
        }
        return {"totalWork": state.work, "totalRest": state.rest};
      }

      // Completely re-draws the view (progress bar, text, buttons, butterbar).
      function redrawView() {
        // Update "progress bar" SVG.
        const oldChild = document.getElementById("svg-container");
        const parent = oldChild.parentElement;
        parent.replaceChild(renderTemplate(), oldChild);

        // Update work/rest times.
        const durations = totalTime();
        document.getElementById("text-work").innerText =
            `work→ ${formatTime(durations.totalWork)}`;
        document.getElementById("text-rest").innerText =
            `${formatTime(durations.totalRest)} ←rest`;
        document.getElementById("text-date").innerText =
            `${formatCurrentDate()}`;

        // Update buttons pressed/unpressed state.
        setPressed("work", state.mode === "work");
        setPressed("rest", state.mode === "rest");
        setPressed("off", state.mode === "off");

        // Set butterbar visibility.
        showButterbar(ws == null || ws.readyState != WebSocket.OPEN);
      }

      // Formats time in seconds into a reasonable human-readable string.
      function formatTime(seconds) {
        const hrs = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor((seconds % 3600) % 60);
        if (hrs != 0) {
          return `${hrs}h${mins.toString().padStart(2, "0")}m`;
        } else if (mins != 0) {
          return `${mins}m${secs.toString().padStart(2, "0")}s`;
        } else {
          return `${secs}s`;
        }
      }

      // Parses 'message' as state in JSON format, and updates the local state
      // based on it.
      function updateViewFromServerState(message) {
        const responseJson = JSON.parse(message);
        if (responseJson.mode != state.mode) {
          console.log("server mode correction: ", responseJson);
        }
        // TODO: consider treating _response_ modeStart as "time ago", i.e.
        //       state.modeStart = now - response.modeStart , so that clock
        //       difference b/w client and server won't matter.
        state = responseJson;
        redrawView();
        setOrClearTimer();
      }

      // Sends a message to the server. Uses websocket connection if available,
      // otherwise falls back to an HTTP POST request.
      function sendMessage(message) {
        if (ws != null) {
          console.log("sending websocket request: " + message)
          ws.send(message);
        } else {
          console.log("sending HTTP POST request: " + message)
          const xhr = new XMLHttpRequest();
          xhr.open("POST", window.location.origin);
          xhr.setRequestHeader("Content-Type", "application/json");

          xhr.onload = function() {
            if (xhr.status === 200) {
              updateViewFromServerState(xhr.responseText);
            } else {
              console.error("Error fetching data:", xhr.statusText);
            }
          };
          xhr.send(message);
        }
      }

      // Effectively "resets" work/rest time on the server by subtracting 100h.
      function reset() {
        sendMessage('{"work": "-100h", "rest": "-100h"}');
      }

      // Formats current date as "YYYY-MM-DD"...
      function formatCurrentDate() {
        const date = new Date();
        const year = date.getFullYear();
        const month = (date.getMonth() + 1).toString().padStart(2, "0");
        const day = date.getDate().toString().padStart(2, "0");
        return `${year}-${month}-${day}`;
      }

      // Template for drawing the "progress bar" SVG div.
      const template = `
      <div id="svg-container" style="grid-row: 1;">
        <svg width="401" height="40" stroke-width="2" stroke="black">
          <rect x="0" y="10" width="%SPLIT_POS%" height="20" fill="#0072d4"/>
          <rect x="%SPLIT_POS%" y="10" width="%REST_WIDTH%" height="20" fill="#489100"/>
          <rect x="1" y="10" width="400" height="20" fill="transparent"/>
          <polygon points="%TARGET_X%, 1, %TARGET_X%, 41" stroke="#ca4898" stroke-dasharray="1, 5"/>
        </svg>
      </div>
      `;

      window.onload = function() {
        createWebSocketConnection();
        redrawView();
        setOrClearTimer();
      };
    </script>
  </head>
  <body>
    <div class="root-container">
      <!-- Row 1: the SVG "progress bar". -->
      <div id="svg-container" style="grid-row: 1;"></div>
      <!-- Row 2: textual representation of the work/rest durations. -->
      <div class="text-container" style="grid-row: 2;">
        <span id="text-work" style="text-align: left;">work→</span>
        <span id="text-date" style="text-align: center;">()</span>
        <span id="text-rest" style="text-align: right;">←rest</span>
      </div>
      <!-- Row 3: the buttons. -->
      <div class="button-container" style="grid-row: 3;">
        <button id="button-work" class="unpressed" onclick="changeMode('work')"
                title="Click when you're working.">work</button>
        <button id="button-rest" class="unpressed" onclick="changeMode('rest')"
                title="Click when you're resting.">rest</button>
        <button id="button-off" class="pressed" onclick="changeMode('off')"
                title="Neither working nor resting.">off the clock</button>
        <button id="button-reset" class="unpressed" onclick="reset()"
                style="margin-left: auto; margin-right: 0px;"
                title="DESTRUCTIVELY reset work/rest durations.">↺</button>
      </div>
      <!-- Row 4: the optional message butterbar. -->
      <div id="butterbar" class="shown" style="grid-row: 4;">
        Lost server connection, re-establishing...
      </div>
    </div>
  </body>
</html>
